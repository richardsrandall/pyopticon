<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Tutorial: Writing Your Own Widgets &mdash; pyopticon 0.2.0 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="_static/jquery.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/sphinx_highlight.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Tutorial: Miscellaneous Useful Features" href="tutorial_4.html" />
    <link rel="prev" title="Tutorial: Building Your Own Dashboards" href="tutorial_2.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            pyopticon
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="gallery.html">Gallery</a></li>
<li class="toctree-l1"><a class="reference internal" href="capabilities.html">Capabilities</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial_1.html">Tutorial: Using an Existing Dashboard</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial_2.html">Tutorial: Building Your Own Dashboards</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Tutorial: Writing Your Own Widgets</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#pyopticon-s-architecture">PyOpticon’s Architecture</a></li>
<li class="toctree-l2"><a class="reference internal" href="#extending-the-genericwidget-class">Extending the GenericWidget Class</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#basics">Basics</a></li>
<li class="toctree-l3"><a class="reference internal" href="#genericwidget-input-output-fields">GenericWidget Input/Output Fields</a></li>
<li class="toctree-l3"><a class="reference internal" href="#genericwidget-methods-to-implement">GenericWidget Methods to Implement</a></li>
<li class="toctree-l3"><a class="reference internal" href="#connecting-to-instruments-with-text-based-serial-protocols">Connecting to Instruments with Text-Based Serial Protocols</a></li>
<li class="toctree-l3"><a class="reference internal" href="#connecting-to-instruments-with-other-python-serial-packages-and-oem-drivers">Connecting to Instruments with Other Python Serial Packages and OEM Drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#important-notes-on-multithreading">Important Notes on Multithreading</a></li>
<li class="toctree-l3"><a class="reference internal" href="#genericwidget-tricks-and-features">GenericWidget Tricks and Features</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#extending-the-minimalwidget-class">Extending the MinimalWidget Class</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="tutorial_4.html">Tutorial: Miscellaneous Useful Features</a></li>
<li class="toctree-l1"><a class="reference internal" href="available_widgets.html">Widgets Made by PyOpticon Users</a></li>
<li class="toctree-l1"><a class="reference internal" href="documentation.html">Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="license.html">License</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">pyopticon</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Tutorial: Writing Your Own Widgets</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/tutorial_3.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="tutorial-writing-your-own-widgets">
<h1>Tutorial: Writing Your Own Widgets<a class="headerlink" href="#tutorial-writing-your-own-widgets" title="Permalink to this heading"></a></h1>
<p>Writing your own widgets is the most complex thing you’re likely to do in PyOpticon. We’ve tried to
make it relatively straightforward. It’s worth it, since once you’re not bound to the library of existing
widgets, you’ll be free to build dashboards to control all kinds of existing and newly-acquired devices in
your own lab or workspace.</p>
<section id="pyopticon-s-architecture">
<h2>PyOpticon’s Architecture<a class="headerlink" href="#pyopticon-s-architecture" title="Permalink to this heading"></a></h2>
<p>Before we go into how to create widgets, we wanted to give a quick overview of what’s actually going on inside
a PyOpticon dashboard. The dashboard is an object containing various graphical and functional elements, including
dictionaries of the constituent widgets that make it up. Running a dashboard entails launching a number of threads,
each executing tasks in
parallel. One ‘main’ thread runs the Dashboard object, operates the graphical user userface, and prompts other threads to do
things. This all takes place in a single thread because Tkinter, the graphics package we use, is generally not
thread-safe. All of the other threads each communicate with a single device. Since serial communications are very amenable
to being split amongst multiple threads, giving each device its own thread works great; we just have to be a little
careful about how those threads go about updating their associated graphical fields.</p>
<p>Here is a graphical finite-state-machine representation of what the main thread is doing:</p>
<img alt="A state machine of the main thread." src="_images/all_fsm.png" />
<p>This isn’t super important to study in detail. While it’s one thread, the serial widget, logging widget, automation widget,
and interlock polling routine are all mostly doing their own things. Not pictured are a bunch of background processes
within the Tkinter package that actually draw and operate the graphical interface (e.g., animating when you click a button, or
showing dropdown when a menu is clicked on).</p>
<p>Each widget’s actions when prompted to connect, update, or disconnect are executed in the widget’s thread. These are discussed
further below, and a graphical finite state machine for an individual widget is shown.</p>
</section>
<section id="extending-the-genericwidget-class">
<h2>Extending the GenericWidget Class<a class="headerlink" href="#extending-the-genericwidget-class" title="Permalink to this heading"></a></h2>
<section id="basics">
<h3>Basics<a class="headerlink" href="#basics" title="Permalink to this heading"></a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">GenericWidget</span></code> class is meant to allow widget development with less tedium and with less knowledge of tkinter,
Pyserial, and other specialized libraries. This is done by defining a superclass (<code class="docutils literal notranslate"><span class="pre">GenericWidget</span></code>) from which subclasses
(e.g., <code class="docutils literal notranslate"><span class="pre">Valco2WayValveWidget</span></code>) are defined. If you haven’t worked much with object-oriented programming before, it’s
probably worth reading a primer elsewhere (like <a class="reference external" href="https://realpython.com/python3-object-oriented-programming/#how-do-you-define-a-class-in-python">this</a>) on classes, objects, and inheritance. In short, the code that all
widgets share is written in a superclass, and when writing a subclass you need only write the code that is unique to the
widget that you’re trying to create.</p>
<p>We recommend using <code class="docutils literal notranslate"><span class="pre">GenericWidget</span></code> as the superclass for all widgets representing physical devices, and in fact for
all widgets except for purely cosmetic ones.
A later section talks about <code class="docutils literal notranslate"><span class="pre">MinimalWidget</span></code>, which lets you build widgets completely from scratch, which
we only recommend if you’re making a purely cosmetic widget like a <code class="docutils literal notranslate"><span class="pre">TitleWidget</span></code>, or if you need really special
behavior and you really know what you’re doing.</p>
<p>We’ll run through an example of building the Valco 2 Way Valve widget from the <code class="docutils literal notranslate"><span class="pre">majumdar_lab_widgets</span></code> package. This is a
convenient example because it’s only got one output field (the valve’s actual position) and one user input field (the desired
valve position). An important first step is to know this device’s serial communication protocol. We’ll assume we know the protocol
for the valve already, but if we didn’t, the next section includes tips on how to find it.</p>
</section>
<section id="genericwidget-input-output-fields">
<h3>GenericWidget Input/Output Fields<a class="headerlink" href="#genericwidget-input-output-fields" title="Permalink to this heading"></a></h3>
<p>The properties of <code class="docutils literal notranslate"><span class="pre">GenericWidget</span></code> subclasses are mostly stored as what PyOpticon refers to as ‘fields’. A field is a
text variable with a text identifier, a corresponding graphical element, and a label. For example, in the
<code class="docutils literal notranslate"><span class="pre">Valco2WayValveWidget</span></code> class, there’s a field for ‘Position Selection’ corresponding to a dropdown menu
and there’s a field for ‘Actual Position’ corresponding to a text readout. Fields are created using the <code class="docutils literal notranslate"><span class="pre">add_field</span></code>
method, read using the <code class="docutils literal notranslate"><span class="pre">get_field</span></code> method, and set using the <code class="docutils literal notranslate"><span class="pre">set_field</span></code> method, all of which are described in the
documentation. The point of using PyOpticon fields rather than instance variables is to let you avoid messing with
tkinter GUI elements and StringVar objects,
provide a clean way for automation scripts to control widgets, and let you avoid manually defining a <code class="docutils literal notranslate"><span class="pre">log_data</span></code>
function for most widgets.</p>
</section>
<section id="genericwidget-methods-to-implement">
<h3>GenericWidget Methods to Implement<a class="headerlink" href="#genericwidget-methods-to-implement" title="Permalink to this heading"></a></h3>
<p>Here is a graphical respresentation of what a GenericWidget does:</p>
<img alt="A state machine of an individual widget." src="_images/widget_fsm.png" />
<p>The overall state logic and the tasks in the light blue blocks are implemented for you in the GenericWidget superclass.
The orange blocks represent methods that you can (and in some cases must) implement whenever you make a new widget, discussed in more detail here:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">__init__</span></code>: Required. The constructor method. Defines the widget’s fields and visual layout.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">on_handshake</span></code>: Strongly recommended. Called when the dashboard begins polling devices. This method should initialize any non- <code class="docutils literal notranslate"><span class="pre">serial.Serial</span></code>
objects needed for communication, check that communication is proceeding as expected, and populate the widget’s fields with
any initial values that are desired. If an exception is raised, the handshake is understood to have failed, and the device
will not be polled.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">on_update</span></code>: Required. Called whenever it’s time to update the widget. Usually this method will query the physical device for
the latest readings, wait to receive them, parse them, and then update the widget’s output fields accordingly.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">on_serial_close</span></code>: Strongly recommended. Called when the dashboard stops polling devices. The dashboard will automatically close any <code class="docutils literal notranslate"><span class="pre">serial.Serial</span></code> objects
that it opened, but this method can close down other device-communication objects and return output fields to some placeholder value.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">on_failed_serial_open</span></code>: Optional. If the widget is initialized with <code class="docutils literal notranslate"><span class="pre">use_serial==True</span></code> and constructing the <code class="docutils literal notranslate"><span class="pre">serial.Serial</span></code> object
fails (e.g. because the COM port doesn’t exist), this method is called. It can do things like set fields’ values to “No Reading”.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">on_confirm</span></code>: Optional. If the widget has input fields, a confirm button will be autogenerated, and this method will be called when it
is clicked. Usually, its job is to parse the input fields’ values and translate them into commands to be sent to the device via a serial connection.</p></li>
</ul>
<p>Below, we’ve included the whole <code class="docutils literal notranslate"><span class="pre">Valco2WayValveWidget</span></code> implementation; reading that is probably the easiest way to
understand what all these methods do. But first, here are a couple of important points:</p>
<ul class="simple">
<li><p>If a widget is initialized with <code class="docutils literal notranslate"><span class="pre">use_serial=True</span></code>, the dashboard will open a <code class="docutils literal notranslate"><span class="pre">serial.Serial</span></code> object for you
that gets stored in the widget’s <code class="docutils literal notranslate"><span class="pre">self.serial_object</span></code> property. It will also worry about closing that object for you
when communication ends. For widgets that update themselves in some other way, e.g. using an OEM Python driver, you’ll
need to take care of these things yourself.</p></li>
<li><p>The default behavior is to use <code class="docutils literal notranslate"><span class="pre">on_update</span></code> as the
<code class="docutils literal notranslate"><span class="pre">on_handshake</span></code> method, with the handshake considered to
have failed if <code class="docutils literal notranslate"><span class="pre">on_update</span></code> raises an exception. Basically, by default you can use a normal update cycle as a
handshake, but you have the option of having a ‘special’ handshake that happens the first time only. You might want to override
<code class="docutils literal notranslate"><span class="pre">on_handshake</span></code> if you want to initialize a special object to handle serial communications with the device,
query the device for values that only need to be checked once (e.g. a device ID), or set input fields’ default values
to match the device’s state at the moment you connect.</p></li>
<li><p>It’s best to initialize most widget properties and graphical elements as PyOpticon fields.
Any PyOpticon fields can be read using <code class="docutils literal notranslate"><span class="pre">get_field</span></code>, set using <code class="docutils literal notranslate"><span class="pre">set_field</span></code>,
controlled in automation scripts using <code class="docutils literal notranslate"><span class="pre">schedule_action</span></code>, and will be logged by default. If you just want
to store internal values that aren’t logged or shown in the GUI, instance variables (e.g. <code class="docutils literal notranslate"><span class="pre">self.some_value=19</span></code>)
work just fine.</p></li>
<li><p>The default behavior of <code class="docutils literal notranslate"><span class="pre">log_data</span></code> as defined in <code class="docutils literal notranslate"><span class="pre">GenericWidget</span></code> is usually fine, but you can override it if you need to
process the data before logging it or log data that aren’t PyOpticon fields. It just needs to return a <code class="docutils literal notranslate"><span class="pre">dict</span></code> of the
names and values of the data to be logged at a given time step.</p></li>
<li><p>Some physical devices are finnicky about receiving too many serial queries in a row, and want a delay between
consecutive commands. Just put a <code class="docutils literal notranslate"><span class="pre">time.sleep(0.05)</span></code> or similar in between successive queries, messing with the time as needed.
Blocking code like this is OK because each device has its own thread.</p></li>
</ul>
<p>With all that in mind, here’s the implementation of <code class="docutils literal notranslate"><span class="pre">Valco2WayValve</span></code>, with some of the comments adjusted from the source code
for clarity and brevity. We just construct a widget, add an input and output field, and define how to send and parse serial
communications with the valve.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">generic_widget</span>

<span class="k">class</span> <span class="nc">Valco2WayValveWidget</span><span class="p">(</span><span class="n">generic_widget</span><span class="o">.</span><span class="n">GenericWidget</span><span class="p">):</span>
    <span class="c1"># Docstrings have been omitted to save space</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">parent_dashboard</span><span class="p">,</span><span class="n">name</span><span class="p">,</span><span class="n">nickname</span><span class="p">,</span><span class="n">default_serial_port</span><span class="p">,</span><span class="n">valve_positions</span><span class="p">,</span><span class="n">valve_id</span><span class="o">=</span><span class="s1">&#39;1&#39;</span><span class="p">):</span>
        <span class="c1"># Initialize the superclass with most of the widget functionality</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">parent_dashboard</span><span class="p">,</span><span class="n">name</span><span class="p">,</span><span class="n">nickname</span><span class="p">,</span><span class="s1">&#39;#ADD8E6&#39;</span><span class="p">,</span><span class="n">default_serial_port</span><span class="o">=</span><span class="n">default_serial_port</span><span class="p">,</span><span class="n">baudrate</span><span class="o">=</span><span class="mi">9600</span><span class="p">)</span>
        <span class="c1"># Record the valve id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">valve_id</span><span class="o">=</span><span class="n">valve_id</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">)</span>
        <span class="c1"># Add a dropdown field</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">valve_positions</span><span class="o">=</span><span class="n">valve_positions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_field</span><span class="p">(</span><span class="n">field_type</span><span class="o">=</span><span class="s1">&#39;dropdown&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;Position Selection&#39;</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="s1">&#39;Selected Position: &#39;</span><span class="p">,</span>
                    <span class="n">default_value</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">valve_positions</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">valve_positions</span><span class="p">)</span>
        <span class="c1"># Add a readout field</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_field</span><span class="p">(</span><span class="n">field_type</span><span class="o">=</span><span class="s1">&#39;text output&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;Actual Position&#39;</span><span class="p">,</span>
                    <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Actual Position: &#39;</span><span class="p">,</span> <span class="n">default_value</span><span class="o">=</span><span class="s1">&#39;No Reading&#39;</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># Move the confirm button</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">move_confirm_button</span><span class="p">(</span><span class="n">row</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span><span class="n">column</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">on_failed_serial_open</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">success</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_field</span><span class="p">(</span><span class="s1">&#39;Actual Position&#39;</span><span class="p">,</span><span class="s1">&#39;No Reading&#39;</span><span class="p">,</span><span class="n">hush_warning</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">on_update</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Send the query</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent_dashboard</span><span class="o">.</span><span class="n">offline_mode</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_serial_object</span><span class="p">()</span><span class="o">.</span><span class="n">reset_input_buffer</span><span class="p">()</span>
            <span class="n">to_write</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">valve_id</span><span class="o">+</span><span class="sa">b</span><span class="s1">&#39;CP</span><span class="se">\r</span><span class="s1">&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_serial_object</span><span class="p">()</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">to_write</span><span class="p">)</span>
        <span class="c1"># Wait a bit</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.2</span><span class="p">)</span>
        <span class="c1"># Read and parse the response</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent_dashboard</span><span class="o">.</span><span class="n">offline_mode</span><span class="p">:</span>
            <span class="n">status</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">serial_object</span><span class="o">.</span><span class="n">readline</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">20</span><span class="p">)</span>
            <span class="n">v</span> <span class="o">=</span> <span class="s1">&#39;A&#39;</span> <span class="k">if</span> <span class="n">v</span><span class="o">&gt;</span><span class="mi">10</span> <span class="k">else</span> <span class="s1">&#39;B&#39;</span>
            <span class="n">v</span> <span class="o">=</span> <span class="s1">&#39;dd&quot;&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;dd</span><span class="se">\r\n</span><span class="s1">&#39;</span>
            <span class="n">status</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">status</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&quot;</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
            <span class="n">is_A</span> <span class="o">=</span> <span class="n">status</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;A&#39;</span>
            <span class="k">if</span> <span class="n">is_A</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_field</span><span class="p">(</span><span class="s1">&#39;Actual Position&#39;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">valve_positions</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_field</span><span class="p">(</span><span class="s1">&#39;Actual Position&#39;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">valve_positions</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">fail_message</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;Unexpected response received from 2-way valve: &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">status</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_field</span><span class="p">(</span><span class="s1">&#39;Actual Position&#39;</span><span class="p">,</span><span class="s1">&#39;Read Error&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">fail_message</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">on_serial_close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;When serial is closed, set all readouts to &#39;None&#39;.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_field</span><span class="p">(</span><span class="s1">&#39;Actual Position&#39;</span><span class="p">,</span><span class="s1">&#39;No Reading&#39;</span><span class="p">,</span><span class="n">hush_warning</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">on_confirm</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;When &#39;confirm&#39; is pressed, send the appropriate commands to the valve.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">selected</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_field</span><span class="p">(</span><span class="s1">&#39;Position Selection&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">selected</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">valve_positions</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&quot;</span><span class="s2">Confirm</span><span class="se">\&quot;</span><span class="s2"> pressed with no/invalid option selected.&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="n">choice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">valve_positions</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">selected</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">choice</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Moving valve </span><span class="se">\&quot;</span><span class="s2">&quot;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">+</span><span class="s2">&quot;</span><span class="se">\&quot;</span><span class="s2"> to </span><span class="se">\&quot;</span><span class="s2">&quot;</span><span class="o">+</span><span class="n">selected</span><span class="o">+</span><span class="s2">&quot;</span><span class="se">\&quot;</span><span class="s2"> (A)&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">serial_object</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">valve_id</span><span class="o">+</span><span class="sa">b</span><span class="s1">&#39;GOA</span><span class="se">\r</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Moving valve </span><span class="se">\&quot;</span><span class="s2">&quot;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">+</span><span class="s2">&quot;</span><span class="se">\&quot;</span><span class="s2"> to </span><span class="se">\&quot;</span><span class="s2">&quot;</span><span class="o">+</span><span class="n">selected</span><span class="o">+</span><span class="s2">&quot;</span><span class="se">\&quot;</span><span class="s2"> (B)&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">serial_object</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">valve_id</span><span class="o">+</span><span class="sa">b</span><span class="s1">&#39;GOB</span><span class="se">\r</span><span class="s1">&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Here’s what the widget ends up looking like:</p>
<img alt="A Valco2WayValve widget" src="_images/valco_widget.png" />
</section>
<section id="connecting-to-instruments-with-text-based-serial-protocols">
<h3>Connecting to Instruments with Text-Based Serial Protocols<a class="headerlink" href="#connecting-to-instruments-with-text-based-serial-protocols" title="Permalink to this heading"></a></h3>
<p>Many instruments communicate with computers by receiving and sending binary-encoded text messages. By default, PyOpticon
widgets use this type of communication, enabled by the pySerial Python package.</p>
<p>In principle, a PyOpticon widget with pySerial can control any instrument that uses a text-based serial protocol.
In practice, finding that protocol can be tricky. The protocol consists of a baud rate (an integer value,
like 19200), a syntax for sending commands, and a syntax in which replies are sent.</p>
<p>It’s easiest if you can find a manual for your device that contains its serial protocol. If that fails, often the
manufacturer will have documentation on the serial protocol that they can send upon request. It may be referred to
as an RS232, DB9, or serial protocol.</p>
<p>If you have a manufacturer-supplied program that can talk to the device, you can also try to listen in on its connection
and reverse-engineer the serial protocol. Some programs that may help do this are portmon, com0com, and realterm. This works
best for simple devices that send the same commands over and over. Trying to reverse-engineer the protocol for a complex
instrument in this way would be quite hard.</p>
<p>To connect to an instrument, find the appropriate set of cables and converters. USB-to-RS232 converters are available
on Amazon and tend to work pretty well. We’ve had some issues using USB-to-many-RS232 multiplexers – it seems a bit
more reliable to use a USB multiplexer coupled to many USB-to-RS232 cables. You can use the serial port scanner to verify
that a new serial port appeared when the instrument was plugged in. Sometimes, you need to change settings on the instrument
to enable serial communications; if so, the manual may explain how to do so.</p>
<p>Before trying to code a PyOpticon widget, we recommend sending the relevant commands manually to make sure the protocol works as
expected. One easy way to do this is to use the pySerial library in the Python shell, accessed via IDLE. The pySerial
website has some useful <a href="#id1"><span class="problematic" id="id2">examples_</span></a>.</p>
<p>On occasion, an instrument will require serial parameters like parity and stop bits that are different from the pySerial default.
As a workaround, in <code class="docutils literal notranslate"><span class="pre">on_handshake</span></code>, close the <code class="docutils literal notranslate"><span class="pre">self.serial_object</span></code> object that the widget auto-creates and replace it
with a new <code class="docutils literal notranslate"><span class="pre">serial.Serial</span></code> instance with the correct parameters and the same serial port.</p>
</section>
<section id="connecting-to-instruments-with-other-python-serial-packages-and-oem-drivers">
<h3>Connecting to Instruments with Other Python Serial Packages and OEM Drivers<a class="headerlink" href="#connecting-to-instruments-with-other-python-serial-packages-and-oem-drivers" title="Permalink to this heading"></a></h3>
<p>There are various other serial communication standards besides RS232 with ASCII-encoded text. One example is the
RS485 standard with the Modbus communication protocol, a system commonly used for industrial controls. Another is
the VISA standard, which helps manufactuers create cross-platform drivers for there instruments. There are
existing Python libraries to facilitate communications using many of these standards, such as minimalmodbus and pyvisa.
Additionally, many instrument manufacturers provide Python drivers to interface with their instruments.</p>
<p>The workflow to use one of these protocols is similar to that for ‘plain’ RS232 serial. First, write a standalone (non-PyOpticon)
Python script that can read from and write to your instrument, ensuring that you understand how Python communicates with your
instrument. Second, in <code class="docutils literal notranslate"><span class="pre">on_handshake</span></code>, initialize whatever object represents your serial connection (e.g. a <code class="docutils literal notranslate"><span class="pre">pymodbus.ModbusSerialClient</span></code> object).
Then, implement the other methods as normal, making sure to close the object however is needed in <code class="docutils literal notranslate"><span class="pre">on_serial_close</span></code>. The built-in
Thorlabs Optical Power Meter widget is a good example of a widget that uses an OEM Python driver.</p>
</section>
<section id="important-notes-on-multithreading">
<h3>Important Notes on Multithreading<a class="headerlink" href="#important-notes-on-multithreading" title="Permalink to this heading"></a></h3>
<p>PyOpticon uses multithreading to allow the use of blocking code in widget methods, which creates a good deal of flexibility in what types of widgets you can make.
Blocking code is code that stops a program thread from doing anything else
until it executes. With non-blocking text-based pySerial communications, you can instantaneously write to the device,
do other things elsewhere in the program, then check back later to see if there was a response. PyOpticon uses this to
query many devices in parallel. However, a pymodbus query will block all other tasks for ~0.1s while it waits for an instrument to respond.
The same is true of using most OEM drivers to query an instrument.
Because each device has its own thread (and usually each widget, unless explicitly told to share a thread),
blocking code in handshakes, updates, and confirms will generally not gum up the program.
While one thread waits for a certain device to respond, other parts of the program can go about their tasks.</p>
<p>However, as a result of this architecture, there are two things that you need to be aware of:</p>
<ul class="simple">
<li><p>A widget’s <code class="docutils literal notranslate"><span class="pre">on_handshake</span></code>, <code class="docutils literal notranslate"><span class="pre">on_update</span></code>, and <code class="docutils literal notranslate"><span class="pre">on_confirm</span></code> need to interact with the widget, the Dashboard object,
and graphical interface objects in thread-safe ways.
Each of those methods executes in a widget’s thread, while the Dashboard and graphical interface live in a different
thread, and blindly manipulating variables in one thread from another thread is a recipe for disaster. <code class="docutils literal notranslate"><span class="pre">set_field</span></code> and
<code class="docutils literal notranslate"><span class="pre">get_field</span></code> are written to be thread-safe, so you can use them without worrying. To give you more flexibility, we also
provide <code class="docutils literal notranslate"><span class="pre">do_threadsafe</span></code>, which can be used like so: <code class="docutils literal notranslate"><span class="pre">self.do_threadsafe(lambda:</span> <span class="pre">self.disable_field(&quot;Setpoint&quot;))</span></code>.</p></li>
<li><p>To shut down widgets promptly, <code class="docutils literal notranslate"><span class="pre">on_serial_close</span></code> executes immediately in the main dashboard thread, unlike <code class="docutils literal notranslate"><span class="pre">on_update</span></code> etc. that
execute in the widgets’ respective threads. One can have a situation where an <code class="docutils literal notranslate"><span class="pre">on_update</span></code> method queries a device then waits for a response,
but while it’s waiting, <code class="docutils literal notranslate"><span class="pre">on_serial_close</span></code> is called serial connection closes, and it then attempts to read from a serial object that is closed.
Therefore, before reading or writing to serial, <code class="docutils literal notranslate"><span class="pre">on_update</span></code> and <code class="docutils literal notranslate"><span class="pre">on_confirm</span></code> should double-check that the serial
connection is still open by checking the widget’s <code class="docutils literal notranslate"><span class="pre">self.parent_dashboard.serial_connected</span></code> flag. Calling <code class="docutils literal notranslate"><span class="pre">set_field</span></code> while
serial is closed prints a warning to help you remember to do this, though it can be suppressed by giving <code class="docutils literal notranslate"><span class="pre">set_field</span></code> the argument <code class="docutils literal notranslate"><span class="pre">hush_warning=True</span></code>.</p></li>
</ul>
<p>Be careful if you choose to take advantage of packages that offer asynchronous access to serial devices, e.g. OEM drivers
that make use of asyncio. In many cases it’s simplest to force the thread to wait until an asynchronous method finishes before
moving to the next task, essentially turning it into blocking code. Since each widget gets its own thread, and you likely only need to do
a handful of calls every update cycle, doing so is unlikely to gum up the entire dashboard.</p>
</section>
<section id="genericwidget-tricks-and-features">
<h3>GenericWidget Tricks and Features<a class="headerlink" href="#genericwidget-tricks-and-features" title="Permalink to this heading"></a></h3>
<p>In developing widgets for our own lab, there were a few things for which we added special options in the <code class="docutils literal notranslate"><span class="pre">GenericWidget</span></code>
class. They’re buried in the documentation, so we will quickly highlight some here:</p>
<ul class="simple">
<li><p>Offline-mode testing: Sometimes it’s nice to do a lot of the cosmetic setup of a widget on a laptop or at home,
with dummy values replacing values read from a physical device, then come
into lab just to do the final integration with the hardware. A dashboard can be initialized with <code class="docutils literal notranslate"><span class="pre">offline_mode=True</span></code> to
indicate this, which sets a dashboard’s <code class="docutils literal notranslate"><span class="pre">offline_mode</span></code> flag for widgets to check. Then, in an <code class="docutils literal notranslate"><span class="pre">on_update</span></code> method, you can
say something like <code class="docutils literal notranslate"><span class="pre">status</span> <span class="pre">=</span> <span class="pre">self.serial_object.readline()</span> <span class="pre">if</span> <span class="pre">not</span> <span class="pre">self.parent_dashboard.offline_mode</span> <span class="pre">else</span> <span class="pre">b'123C\n'</span></code>, and proceed
with parsing as though b’123\n’ were an actual response from a real device.</p></li>
<li><p>Disabling fields: If you want to grey out an input field, perhaps so you can’t change it while the serial connection
is active, the <code class="docutils literal notranslate"><span class="pre">disable_field</span></code> and <code class="docutils literal notranslate"><span class="pre">enable_field</span></code> methods will let you do that.</p></li>
<li><p>Moving confirm button: If the ‘Confirm’ button is autogenerated in an inconvenient place,
you can move it using the <code class="docutils literal notranslate"><span class="pre">move_confirm_button</span></code> method.</p></li>
<li><p>Overriding colors: The <code class="docutils literal notranslate"><span class="pre">override_color</span></code> method lets you change the color of a widget’s frame from the default for that type of widget.</p></li>
<li><p>Updating a widget less often: The optional <code class="docutils literal notranslate"><span class="pre">update_every_n_cycles</span></code> argument to the <code class="docutils literal notranslate"><span class="pre">GenericWidget</span></code> constructor creates a widget that updates every
2nd, 3rd, or nth cycle instead of every cycle. This is useful for instruments that take a while to respond to serial queries.
The <code class="docutils literal notranslate"><span class="pre">SpicinessWidget</span></code> class is initalized
with <code class="docutils literal notranslate"><span class="pre">update_every_n_cycles=3</span></code> to demonstrate this option.</p></li>
<li><p>Widgets sharing a thread: sometimes it may be necessary for multiple widgets to share one serial connection. This happened for us
when we have several mass flow controllers that are all controlled by one control box with a single serial connection. You can
initialize a GenericWidget with the parameter <code class="docutils literal notranslate"><span class="pre">widget_to_share_thread_with</span></code> and it will create a single thread for multiple widgets.
The thread maintains a queue of tasks, so you can be sure that the widgets’ <code class="docutils literal notranslate"><span class="pre">on_handshake</span></code>, <code class="docutils literal notranslate"><span class="pre">on_update</span></code>, and <code class="docutils literal notranslate"><span class="pre">on_serial_close</span></code> methods will always
be called in the same order (the order in which the widgets were added to the dashboard).</p></li>
</ul>
</section>
</section>
<section id="extending-the-minimalwidget-class">
<h2>Extending the MinimalWidget Class<a class="headerlink" href="#extending-the-minimalwidget-class" title="Permalink to this heading"></a></h2>
<p>For all widgets representing physical devices, we suggest extending the <code class="docutils literal notranslate"><span class="pre">GenericWidget</span></code> class, which saves a lot of work
compared to building one from scratch. Even for widgets that don’t represent a physical device, e.g. some kind of
calculator widget to help the operator, it may be easiest to just use a <code class="docutils literal notranslate"><span class="pre">GenericWidget</span></code> subclass with the
<code class="docutils literal notranslate"><span class="pre">use_serial=False</span></code> option, which can save some messing with tkinter GUI elements. However, we include the <code class="docutils literal notranslate"><span class="pre">MinimalWidget</span></code>
class in case you really do want to build a widget from scratch.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">MinimalWidget</span></code> class implements only the few methods that are required for a widget to interface with its parent
dashboard (<code class="docutils literal notranslate"><span class="pre">on_handshake</span></code>, <code class="docutils literal notranslate"><span class="pre">on_update</span></code>, <code class="docutils literal notranslate"><span class="pre">on_confirm</span></code>, and <code class="docutils literal notranslate"><span class="pre">on_serial_close</span></code>).
All of them default to doing nothing, though of course you can override them.</p>
<p>The most likely use of the <code class="docutils literal notranslate"><span class="pre">MinimalWidget</span></code> is writing a widget that is purely cosmetic. Such a widget needs none of the
serial or logging machinery of a <code class="docutils literal notranslate"><span class="pre">GenericWidget</span></code> subclass, nor would it want to be stuck with a <code class="docutils literal notranslate"><span class="pre">GenericWidget</span></code> subclass’
colored frame and gridded layout. A MinimalWidget class just contains a tkinter frame object on which anything can be drawn,
e.g. text, images, etc. The only widget we’ve written that extends <code class="docutils literal notranslate"><span class="pre">MinimalWidget</span></code> is the <code class="docutils literal notranslate"><span class="pre">TitleWidget</span></code>, whose entire
implementation is included below:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">tkinter</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">tkinter.font</span> <span class="k">as</span> <span class="nn">tkFont</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">minimal_widget</span>

<span class="k">class</span> <span class="nc">TitleWidget</span><span class="p">(</span><span class="n">minimal_widget</span><span class="o">.</span><span class="n">MinimalWidget</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; A simple widget containing only text, intended for making a big-text title for a dashboard.</span>
<span class="sd">    Uses the MinimalWidget superclass, since all of the GenericWidget machinery is unnecessary.\n</span>

<span class="sd">    :param parent_dashboard: The dashboard object to which this device will be added</span>
<span class="sd">    :type parent_dashboard: pyopticon.dashboard.PyOpticonDashboard</span>
<span class="sd">    :param title: The text to be displayed within this widget, called &#39;title&#39; because it&#39;s likely to be the title of the entire dashboard.</span>
<span class="sd">    :type title: str</span>
<span class="sd">    :param font_size: The size of font to be used in the text, as an integer.</span>
<span class="sd">    :type font_size: int</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">parent_dashboard</span><span class="p">,</span><span class="n">title</span><span class="p">,</span><span class="n">font_size</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Constructor for a title widget.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">parent_dashboard</span><span class="p">)</span>
        <span class="n">fontStyle</span> <span class="o">=</span> <span class="n">tkFont</span><span class="o">.</span><span class="n">Font</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">font_size</span><span class="p">)</span>
        <span class="c1"># This entire widget is just one big Label</span>
        <span class="n">Label</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frame</span><span class="p">,</span> <span class="n">font</span> <span class="o">=</span> <span class="n">fontStyle</span><span class="p">,</span> <span class="n">text</span> <span class="o">=</span> <span class="n">title</span><span class="p">)</span><span class="o">.</span><span class="n">pack</span><span class="p">()</span>
</pre></div>
</div>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="tutorial_2.html" class="btn btn-neutral float-left" title="Tutorial: Building Your Own Dashboards" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="tutorial_4.html" class="btn btn-neutral float-right" title="Tutorial: Miscellaneous Useful Features" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Richard Randall.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>